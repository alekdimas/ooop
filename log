package com.example.individualproxy

import android.content.Intent
import android.net.VpnService
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.activity.result.ActivityResultLauncher
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.RectangleShape
import androidx.lifecycle.ViewModelProvider
import androidx.tv.material3.ExperimentalTvMaterial3Api
import androidx.tv.material3.Surface
import com.example.individualproxy.model.MyApp
import com.example.individualproxy.model.data.repository.VpnRepository
import com.example.individualproxy.ui.theme.IndividualProxyTheme
import com.example.individualproxy.viewModel.AuthViewModel
import com.example.individualproxy.viewModel.AuthViewModelFactory
import com.example.individualproxy.viewModel.VpnViewModel
import com.example.individualproxy.viewModel.VpnViewModelFactory
import com.example.individualproxy.views.AppNavGraph

class MainActivity : ComponentActivity() {
    private lateinit var authViewModel: AuthViewModel
    private lateinit var vpnViewModel: VpnViewModel
    private lateinit var vpnPermissionLauncher: ActivityResultLauncher<Intent>
    private var pendingCountry: String? = null

    @OptIn(ExperimentalTvMaterial3Api::class)
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        vpnPermissionLauncher = registerForActivityResult(
            ActivityResultContracts.StartActivityForResult()
        ) { result ->
            if (result.resultCode == RESULT_OK) {
                pendingCountry?.let { country ->
                    vpnViewModel.connectToVpn(country)
                }
            }
            pendingCountry = null
        }

        val app = application as MyApp

        authViewModel = ViewModelProvider(
            this,
            AuthViewModelFactory(app)
        )[AuthViewModel::class.java]

        val vpnRepository = VpnRepository(app.vpnApi, app.sessionManager)
        vpnViewModel = ViewModelProvider(
            this,
            VpnViewModelFactory(application, vpnRepository)
        )[VpnViewModel::class.java]

        setContent {
            IndividualProxyTheme {
                Surface(
                    modifier = Modifier.fillMaxSize(),
                    shape = RectangleShape
                ) {
                    AppNavGraph(
                        authViewModel = authViewModel,
                        vpnViewModel = vpnViewModel,
                        onConnectVpnRequested = { country ->
                            pendingCountry = country
                            val intent = VpnService.prepare(this@MainActivity)
                            if (intent != null) {
                                vpnPermissionLauncher.launch(intent)
                            } else {
                                vpnViewModel.connectToVpn(country)
                            }
                        },
                        onDisconnectVpnRequested = {
                            vpnViewModel.disconnectVpn()  // Добавлен недостающий параметр
                        }
                    )
                }
            }
        }
    }
}

<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.individualproxy">

    <uses-permission android:name="android.permission.FOREGROUND_SERVICE"/>
    <uses-permission android:name="android.permission.INTERNET"/>
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE_SPECIAL_USE"/>
    <uses-permission android:name="android.permission.CHANGE_NETWORK_STATE"/>
    <uses-permission android:name="android.permission.WRITE_SETTINGS"/>
    <uses-permission android:name="android.permission.CHANGE_WIFI_STATE"/>
    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/>
    <uses-permission android:name="android.permission.ACCESS_WIFI_STATE"/>
    <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION"/>

    <uses-feature
        android:name="android.hardware.touchscreen"
        android:required="false" />
    <uses-feature
        android:name="android.software.leanback"
        android:required="false" />

    <application
        android:name=".model.MyApp"
        android:networkSecurityConfig="@xml/network_security_config"
        android:usesCleartextTraffic="true"
        android:allowBackup="true"
        android:enableOnBackInvokedCallback="true"
        android:banner="@mipmap/ic_launcher"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:supportsRtl="true"
        android:theme="@style/Theme.IndividualProxy">

        <activity
            android:name=".MainActivity"
            android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
                <category android:name="android.intent.category.LEANBACK_LAUNCHER" />
            </intent-filter>
        </activity>

        <service
            android:foregroundServiceType="specialUse"
            android:name=".model.data.services.VpnConnectionService"
            android:permission="android.permission.BIND_VPN_SERVICE"
            android:exported="true">
            <intent-filter>
                <action android:name="android.net.VpnService"/>
            </intent-filter>
        </service>

    </application>

</manifest>

package com.example.individualproxy.model.data.services

import android.app.NotificationChannel
import android.app.NotificationManager
import android.content.Context
import android.content.Intent
import android.net.ConnectivityManager
import android.net.VpnService
import android.os.Build
import android.os.Handler
import android.os.Looper
import android.os.ParcelFileDescriptor
import android.util.Log
import androidx.core.app.NotificationCompat
import com.example.individualproxy.model.MyApp
import com.example.individualproxy.model.data.api.VpnApi
import com.example.individualproxy.model.data.session.SessionManager
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.cancel
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import libXray.DialerController
import libXray.LibXray
import org.json.JSONObject
import java.io.File
import java.io.IOException
import java.util.concurrent.atomic.AtomicBoolean
import kotlin.io.encoding.Base64
import kotlin.io.encoding.ExperimentalEncodingApi

class VpnConnectionService : VpnService() {

    private var vpnInterface: ParcelFileDescriptor? = null
    private var currentConfig: String? = null
    private val isRunning = AtomicBoolean(false)
    private val scope = CoroutineScope(Dispatchers.IO + Job())
    private val handler = Handler(Looper.getMainLooper())
    private val vpnApi: VpnApi by lazy { (application as MyApp).vpnApi }
    private val sessionManager: SessionManager by lazy { (application as MyApp).sessionManager }

    private val dialerController = object : DialerController {
        override fun protectFd(socket: Long): Boolean {
            val result = try {
                val success = protect(socket.toInt())
                // Убираем спам в логах, логируем только ошибки
                if (!success) Log.e("VPN_SERVICE", "Failed to protect socket $socket")
                success
            } catch (e: Exception) {
                Log.e("VPN_SERVICE", "Socket protection failed", e)
                false
            }
            return result
        }
    }

    override fun onCreate() {
        super.onCreate()
        createNotificationChannel()
        LibXray.registerDialerController(dialerController)
        Log.d("VPN_SERVICE", "Service created")
    }

    private fun createNotificationChannel() {
        val notificationManager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
        if (notificationManager.getNotificationChannel("vpn_channel") == null) {
            NotificationChannel(
                "vpn_channel",
                "VPN Service",
                NotificationManager.IMPORTANCE_LOW
            ).apply {
                description = "VPN service using Xray-core"
                notificationManager.createNotificationChannel(this)
            }
        }
    }

    @OptIn(ExperimentalEncodingApi::class)
    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        if (intent?.action == "STOP_VPN") {
            Log.d("VPN_SERVICE", "Received STOP_VPN action")
            stopVpn()
            stopSelf()
            return START_NOT_STICKY
        }

        startForeground(
            NOTIFICATION_ID,
            NotificationCompat.Builder(this, "vpn_channel")
                .setContentTitle("Xray VPN Active")
                .setContentText("Protected by Xray-core")
                .setSmallIcon(android.R.drawable.ic_lock_lock)
                .setPriority(NotificationCompat.PRIORITY_LOW)
                .build()
        )

        currentConfig = intent?.getStringExtra("CONFIG")
        currentConfig?.let {
            startVpn(it)
            Log.d("VPN_SERVICE", "Using config: $it")
        } ?: run {
            Log.e("VPN_SERVICE", "No config provided in intent")
            stopSelf()
        }

        return START_STICKY
    }

    @OptIn(ExperimentalEncodingApi::class)
    private fun startVpn(config: String) {
        if (isRunning.get()) return

        scope.launch {
            try {
                val builder = Builder().apply {
                    setSession("Xray VPN")
                    setMtu(1500)
                    addAddress("172.19.0.1", 28)
                    addRoute("0.0.0.0", 0) // Весь IPv4
                    addRoute("::", 0) // Весь IPv6
                    addDisallowedApplication(packageName)
                    addDnsServer("8.8.8.8")
                    addDnsServer("8.8.4.4")
                    setBlocking(true)
                    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
                        setMetered(false)
                    }
                }

                vpnInterface = builder.establish() ?: throw IOException("Failed to create VPN interface")
                Log.d("VPN_SERVICE", "VPN interface created: ${vpnInterface!!.fileDescriptor}")

                val decodedBytes = Base64.decode(config)
                val jsonConfig = String(decodedBytes, Charsets.UTF_8)
                Log.d("VPN_SERVICE", "Decoded JSON config: $jsonConfig")
                val configObj = JSONObject(jsonConfig)
                val configPath = configObj.getString("ConfigPath")
                val xrayConfigRaw = File(configPath).readText()
                Log.d("VPN_SERVICE", "Xray config from file: $xrayConfigRaw")

                // Проверка доступности файла
                val configFile = File(configPath)
                if (!configFile.exists() || !configFile.canRead()) {
                    throw IllegalStateException("Config file not found or unreadable: $configPath")
                }

                // Передаём оригинальный Base64-конфиг с DatDir и ConfigPath
                val base64Response = LibXray.runXray(config)
                val decodedResponseBytes = Base64.decode(base64Response)
                val jsonResponse = String(decodedResponseBytes, Charsets.UTF_8)
                Log.d("VPN_SERVICE", "Xray response: $jsonResponse")

                val responseJson = JSONObject(jsonResponse)
                if (!responseJson.optBoolean("success", false)) {
                    throw IllegalStateException("Xray error: ${responseJson.toString(2)}")
                }

                delay(1000) // Даём Xray время запуститься

                isRunning.set(true)
                Log.d("VPN_SERVICE", "VPN started successfully")

                // Логи ошибок Xray
                val errorLogFile = File("/data/user/0/com.example.individualproxy/files/xray_error.log")
                if (errorLogFile.exists()) {
                    val errors = errorLogFile.readText()
                    if (errors.isNotEmpty()) {
                        Log.e("VPN_SERVICE", "Xray error log: $errors")
                    }
                }

            } catch (e: Exception) {
                Log.e("VPN_SERVICE", "Failed to start VPN", e)
                stopVpn()
                stopSelf()
            }
        }
    }

    private fun stopVpn() {
        Log.d("VPN_SERVICE", "Stopping VPN")
        isRunning.set(false)
        try {
            LibXray.stopXray()
            Log.d("VPN_SERVICE", "Xray stop called")
        } catch (e: Exception) {
            Log.e("VPN_SERVICE", "Failed to stop Xray", e)
        }
        try {
            vpnInterface?.close()
            vpnInterface = null
            Log.d("VPN_SERVICE", "VPN interface closed")
        } catch (e: IOException) {
            Log.e("VPN_SERVICE", "Failed to close VPN interface", e)
        }
        resetNetworkSettings()
    }

    private val checkSubscription = object : Runnable {
        override fun run() {
            if (!isRunning.get()) return

            CoroutineScope(Dispatchers.IO).launch {
                try {
                    sessionManager.getUserToken().let { token ->
                        val response = vpnApi.checkSubscription(com.example.individualproxy.model.data.vpn.RequestVpnStatus(token))
                        if (response.isSuccessful && !response.body()?.subscriptionIsActive!!) {
                            stopSelf()
                        }
                    }
                } catch (e: Exception) {
                    Log.e("VPN_SERVICE", "Subscription check failed", e)
                } finally {
                    scheduleNextCheck()
                }
            }
        }
    }

    private fun scheduleNextCheck() {
        if (isRunning.get()) {
            handler.postDelayed(checkSubscription, 900_000)
        }
    }

    override fun onDestroy() {
        Log.d("VPN_SERVICE", "Service onDestroy called. Running state: ${isRunning.get()}")
        scope.cancel()
        handler.removeCallbacks(checkSubscription)
        stopForeground(true)
        resetNetworkSettings()
        Log.d("VPN_SERVICE", "Service destroyed")
        super.onDestroy()
    }

    private fun resetNetworkSettings() {
        try {
            val connectivityManager = getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager
            connectivityManager.bindProcessToNetwork(null)
            Log.d("VPN_SERVICE", "Network unbound from process in service")

            val dnsResetCommand = "setprop net.dns1 10.0.2.3"
            Runtime.getRuntime().exec(arrayOf("sh", "-c", dnsResetCommand))
            Log.d("VPN_SERVICE", "DNS reset to 10.0.2.3 attempted")

            val dnsResetPublic = "setprop net.dns1 8.8.8.8"
            Runtime.getRuntime().exec(arrayOf("sh", "-c", dnsResetPublic))
            Log.d("VPN_SERVICE", "DNS reset to 8.8.8.8 attempted")
        } catch (e: Exception) {
            Log.e("VPN_SERVICE", "Failed to reset network settings in service", e)
        }
    }

    companion object {
        const val NOTIFICATION_ID = 1337
    }
}
package com.example.individualproxy.viewModel

import android.app.Application
import android.content.Context
import android.content.Intent
import android.net.ConnectivityManager
import android.net.Network
import android.net.NetworkCapabilities
import android.net.NetworkRequest
import android.util.Log
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.viewModelScope
import com.example.individualproxy.model.data.repository.VpnRepository
import com.example.individualproxy.model.data.services.VpnConnectionService
import com.example.individualproxy.model.data.vpn.Country
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch
import org.json.JSONObject
import java.io.File
import kotlin.io.encoding.Base64
import kotlin.io.encoding.ExperimentalEncodingApi

class VpnViewModel(
    application: Application,
    private val repository: VpnRepository
) : AndroidViewModel(application) {

    val subscriptionActive = MutableLiveData<Boolean>()
    val errorMessage = MutableLiveData<String?>()

    private val _isVpnEnabled = MutableStateFlow(false)
    val isVpnEnabled: StateFlow<Boolean> = _isVpnEnabled

    private val _countries = MutableStateFlow<List<Country>>(emptyList())
    val countries: StateFlow<List<Country>> = _countries

    private val _isLoading = MutableStateFlow(false)
    val isLoading: StateFlow<Boolean> = _isLoading.asStateFlow()

    private val _countriesError = MutableStateFlow<String?>(null)
    val countriesError: StateFlow<String?> = _countriesError.asStateFlow()

    init {
        viewModelScope.launch {
            _isVpnEnabled.value = repository.getVpnEnabledState()

            repository.getVpnEnabledFlow().collect { enabled ->
                _isVpnEnabled.value = enabled
            }
        }
    }

    fun loadCountries() {
        viewModelScope.launch {
            _isLoading.value = true
            repository.getCountries().fold(
                onSuccess = { countries ->
                    _countries.value = countries
                    _countriesError.value = null
                },
                onFailure = { error ->
                    _countriesError.value = error.message
                }
            )
            _isLoading.value = false
        }
    }

    @OptIn(ExperimentalEncodingApi::class)
    fun connectToVpn(country: String?) {
        viewModelScope.launch {
            repository.getVpnConfig(country).fold(
                onSuccess = { response ->
                    subscriptionActive.value = response.subscriptionIsActive
                    if (response.subscriptionIsActive) {
                        Log.d("VPN_SERVICE", "Received VPN config: ${response.config}")
                        val configPath = saveConfigToInternalStorage(response.config)
                        val datDirectoryPath = getOrCreateDatFilesDirectory()
                        val jsonConfig = createConfigJson(datDirectoryPath, configPath)
                        val base64Config = Base64.encode(jsonConfig.toByteArray())
                        startVpnService(base64Config)
                        repository.setVpnEnabled(true)
                    }
                },
                onFailure = { throwable ->
                    errorMessage.value = throwable.message
                    val fallbackConfig = """
{
    "log": {
        "loglevel": "debug",
        "access": "/data/user/0/com.example.individualproxy/files/xray_access.log",
        "error": "/data/user/0/com.example.individualproxy/files/xray_error.log"
    },
    "dns": {
        "servers": [
            "8.8.8.8",
            "8.8.4.4"
        ]
    },
    "inbounds": [
        {
            "port": 10808,
            "protocol": "socks",
            "settings": {
                "auth": "noauth",
                "udp": true,
                "ip": "127.0.0.1"
            },
            "tag": "socks-in"
        }
    ],
    "outbounds": [
        {
            "protocol": "vless",
            "settings": {
                "vnext": [
                    {
                        "address": "95.216.125.17",
                        "port": 443,
                        "users": [
                            {
                                "id": "b37458f5-8efa-418c-9f9f-0cfbbf41e5fe",
                                "encryption": "none",
                                "flow": "xtls-rprx-vision"
                            }
                        ]
                    }
                ]
            },
            "streamSettings": {
                "network": "tcp",
                "security": "reality",
                "realitySettings": {
                    "serverName": "asus.com",
                    "fingerprint": "chrome",
                    "publicKey": "YNU3-NsquulMjTPTvxCObCUCEWzvYaHtpOctezNeGSo",
                    "shortId": "1dfc79e3",
                    "spiderX": "/"
                }
            },
            "tag": "proxy"
        }
    ],
    "routing": {
        "domainStrategy": "IPIfNonMatch",
        "rules": [
            {
                "type": "field",
                "inboundTag": ["socks-in"],
                "outboundTag": "proxy"
            }
        ]
    }
}
""".trimIndent()
                    Log.d("VPN_SERVICE", "Using default config: $fallbackConfig")
                    val configPath = saveConfigToInternalStorage(fallbackConfig)
                    val datDirectoryPath = getOrCreateDatFilesDirectory()
                    val jsonConfig = createConfigJson(datDirectoryPath, configPath)
                    val base64Config = Base64.encode(jsonConfig.toByteArray())
                    startVpnService(base64Config)
                    repository.setVpnEnabled(true)
                }
            )
        }
    }

    private fun saveConfigToInternalStorage(config: String): String {
        val context = getApplication<Application>().applicationContext
        try {
            Log.d("VPN_SERVICE", "Saving config to internal storage: $config")
            JSONObject(config)
            Log.d("VPN_SERVICE", "VPN configuration JSON is valid")
        } catch (e: Exception) {
            Log.e("VPN_SERVICE", "Invalid VPN configuration JSON", e)
            throw IllegalStateException("Invalid VPN configuration JSON: ${e.message}")
        }
        return File(context.filesDir, "vpn_config.json").apply {
            writeText(config)
        }.absolutePath
    }

    private fun getOrCreateDatFilesDirectory(): String {
        val context = getApplication<Application>().applicationContext
        val datDir = File(context.filesDir, "dat_files").apply {
            if (!exists()) mkdir()
        }
        copyDatFilesFromAssets(datDir)
        return datDir.absolutePath
    }

    private fun copyDatFilesFromAssets(targetDir: File) {
        val context = getApplication<Application>().applicationContext
        val filesToCopy = listOf("geoip.dat", "geosite.dat")
        filesToCopy.forEach { fileName ->
            val targetFile = File(targetDir, fileName)
            if (!targetFile.exists()) {
                try {
                    context.assets.open(fileName).use { input ->
                        targetFile.outputStream().use { output ->
                            input.copyTo(output)
                        }
                    }
                } catch (e: Exception) {
                    errorMessage.postValue("Failed to copy $fileName: ${e.message}")
                }
            }
        }
    }

    private fun createConfigJson(datDirectory: String, configPath: String): String {
        return JSONObject().apply {
            put("DatDir", datDirectory)
            put("ConfigPath", configPath)
        }.toString()
    }

    private fun startVpnService(base64Config: String? = null) {
        val intent = Intent(getApplication(), VpnConnectionService::class.java).apply {
            putExtra("CONFIG", base64Config)
        }
        getApplication<Application>().startForegroundService(intent)
    }

    fun disconnectVpn() {
        viewModelScope.launch {
            Log.d("VPN_SERVICE", "Disconnecting VPN")
            repository.setVpnEnabled(false)
            stopVpnService()
            repository.clearConfig()
            launch {
                repository.releaseConfig().fold(
                    onSuccess = { Log.d("VPN_SERVICE", "Config released successfully") },
                    onFailure = { e -> Log.e("VPN_SERVICE", "Failed to release config", e) }
                )
            }
            try {
                resetNetworkSettings()
                Log.d("VPN_SERVICE", "Network reset attempted")
            } catch (e: SecurityException) {
                Log.e("VPN_SERVICE", "Failed to reset network settings", e)
                errorMessage.postValue("Failed to reset network settings: ${e.message}")
            }
        }
    }

    private fun stopVpnService() {
        val intent = Intent(getApplication(), VpnConnectionService::class.java).apply {
            action = "STOP_VPN"
        }
        getApplication<Application>().startService(intent)
        Log.d("VPN_SERVICE", "Stop VPN service intent sent")
    }

    private fun resetNetworkSettings() {
        val context = getApplication<Application>().applicationContext
        val connectivityManager = context.getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager
        try {
            connectivityManager.bindProcessToNetwork(null)
            Log.d("VPN_SERVICE", "Network unbound from process")

            val dnsResetCommand = "setprop net.dns1 10.0.2.3"
            Runtime.getRuntime().exec(arrayOf("sh", "-c", dnsResetCommand))
            Log.d("VPN_SERVICE", "DNS reset to 10.0.2.3 attempted")

            val dnsResetPublic = "setprop net.dns1 8.8.8.8"
            Runtime.getRuntime().exec(arrayOf("sh", "-c", dnsResetPublic))
            Log.d("VPN_SERVICE", "DNS reset to 8.8.8.8 attempted")

            val networkRequest = NetworkRequest.Builder()
                .addTransportType(NetworkCapabilities.TRANSPORT_WIFI)
                .addTransportType(NetworkCapabilities.TRANSPORT_CELLULAR)
                .build()
            connectivityManager.requestNetwork(networkRequest, object : ConnectivityManager.NetworkCallback() {
                override fun onAvailable(network: Network) {
                    super.onAvailable(network)
                    Log.d("VPN_SERVICE", "Network is available: $network")
                    connectivityManager.bindProcessToNetwork(network)
                    try {
                        connectivityManager.reportNetworkConnectivity(network, true)
                        Log.d("VPN_SERVICE", "Reported network connectivity as available")
                    } catch (e: SecurityException) {
                        Log.e("VPN_SERVICE", "Failed to report network connectivity", e)
                        errorMessage.postValue("Failed to report network connectivity: ${e.message}")
                    }
                }
                override fun onLost(network: Network) {
                    super.onLost(network)
                    Log.d("VPN_SERVICE", "Network is lost: $network")
                    connectivityManager.bindProcessToNetwork(null)
                }
            })
        } catch (e: SecurityException) {
            Log.e("VPN_SERVICE", "Failed to reset network settings", e)
            errorMessage.postValue("Failed to reset network settings: ${e.message}")
        }
    }
}

data class Country(val code: String, val name: String)
